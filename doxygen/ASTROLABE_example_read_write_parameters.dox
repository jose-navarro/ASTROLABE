/** \page rwpars Reading (and incidentally writing) parameter data using the generic reader (and incidentally writer) classes

\section rwpars-example About the example

The following is an example showing how to read a "data channel" containing ASTROLABE parameters and write the same data to an ASTROLABE text parameter file.

A few comments on the example:

- This example is the counterpart of that shown in \ref wpars. That is, the data generated by that tandem writer is read by this reader.
- This example is very similar to the one shown in \ref rwobs but illustrates that parameter data channels do not include o-records.
- The main function in the example reads data from whatever channel (sockets, text or binary files) and writes the parameters to an ASTROLABE parameters text file - to check that the input data have been correctly read. Note that for a full example showing how to write parameter data, it is better to check the example \ref wpars.
- Function "set_synthetic_lineage_data" creates a fake lineage object with dummy data. It is necessary to write the ASTROLABE header file describing the output data.
- Note that the class RecordStructure and its methods is a mechanism devised to simulate a way to obtain easily the structural information describing a parameter, as the number of tags it includes or the dimension of the parameter vector. Therefore, an although it is necessary to run the example, it is not part of the example itself. Both the header and implementation (.hpp, .cpp) files are reproduced at the bottom of this page. Note that although very similar, these are not identical to the RecordStructure files included in the example dealing with observations (see \ref rwobs); therefore, these may NOT be exchanged.

\warning This example may be used to learn how to read and write observation RESIDUALS. The only changes to make are (1) to use the proper header files ("obs_residuals_reader.hpp and obs_residuals_writer.hpp" instead of "parameter_reader.hpp" and "parameter_writer.hpp") and (2) to modify the class to which objects "reader" and "writer" belong (obs_residuals_reader and obs_residuals_writer instead of parameter_reader and parameter_writer respectively).

\section rwpars-dependencies Dependencies

The generic parameter reader and writer example depends on the following libraries:

- astrolabe
- xerces-c_3
- udunits2
- expat

When using Microsoft compilers, the following library must also be added to the previous list:

- Ws2_32.lib

\section rwpars-code The full example

\code
#include <iostream>
#include <string>
#include "parameter_reader.hpp"
#include "parameter_writer.hpp"

#include "RecordStructure.hpp"

using namespace std;

void
set_synthetic_lineage_data
(lineage_data& lineage)
{
  {
    string svalue;

    // Set the identifier.

    svalue = "ID0";
    lineage.id_set(svalue);

    // Set the name

    svalue = "Sample observation-events file";
    lineage.name_set(svalue);

    // Set the author

    svalue = "Event writer tester program";
    lineage.author_item_add(svalue);

    // Set the organization

    svalue = "The name of the organization goes here";
    lineage.organization_set(svalue);

    // Set the department.

    svalue = "The name of the department goes here";
    lineage.department_set(svalue);

    // Set the project

    svalue = "The name of the project goes here";
    lineage.project_set(svalue);

    // Set the task

    svalue = "The name of the task goes here";
    lineage.task_set(svalue);

    // Set the reference documents

    svalue = "As many entries as desired may be added to refer to related documentation";
    lineage.ref_document_item_add(svalue);

    // Set the remarks

    svalue = "Any interesting remarks go here";
    lineage.remarks_set(svalue);

  }
}

int
main
(int argc, char** argv)
{
  // Parameters defining the behaviour of the reader.

  string           header_filename;
  string           schema_full_path_and_filename;
  int              read_mode;

  //
  // Names of (1) the ASTROLABE header file describing
  // (2) the output file, where we will copy the information
  // read to check that the process works properly.
  //

  string           output_filename;
  string           external_base_name;

  // Synthetic (nonsensical) lineage to add to the ASTROLABE header file.

  lineage_data     output_file_lineage;

  // An ASTROLABE universal parameter reader

  parameter_reader reader;

  //
  // An ASTROLABE universal parameter writer. Used to write somewhere
  // the ASTROLABE data read by this program.
  //

  parameter_writer writer;

  //
  // Data arrays for l-records. Related
  // dimensions.
  //

  double*          the_tags;
  double*          the_expectations;
  double*          the_covariance_values;

  int              the_tags_size;
  int              the_expectations_size;
  int              the_covariance_values_size;

  int              n_tags;
  int              n_expectations;
  int              n_covariance_values;

  // The remaining components found in l-records.

  char             type;
  bool             active;
  char*            identifier;
  int              identifier_width;
  int              instance_identifier;
  double           time_tag;

  // Flags, relevant counters.

  bool             epoch_changed;
  int              n_epochs;
  int              n_l_records;
  bool             server_socket;

  // Auxiliary variables for loops, return codes and miscellaneous purposes.

  int              i;
  int              io_status;
  list<string>     problems;
  string           sid;
  int              total_errors;
  int              total_warnings;

  //
  // The auxiliary class used to describe the catalogue
  // of fake records we'll read.
  //

  RecordStructure  record_structure_catalogue;

  // --------------------------------------------------------------

  //
  // ASK THE USER.
  //
  // Get the name of the ASTROLABE header file describing the data
  // stream that we'll read. Later, once the metadata contained in
  // this header is read, we'll ask more questions if necessary.
  //
  // Get also the FULL PATH to the schema defining the syntax of
  // ASTROLABE header files.
  //

  cout << "Please, type the name of the input ASTROLABE header file: ";
  cin >> header_filename;

  cout << "Type now the FULL PATH and file name of the schema defining their syntax: ";
  cin >> schema_full_path_and_filename;

  // --------------------------------------------------------------

  //
  // PARSE the ASTROLABE header file
  //
  // This will load the metadata. If errors are detected (the header
  // file might be incorrect) these will be reported.
  //

  //
  // First, tell the reader where is located the schema file defining
  // the syntax of ASTROLABE header files. This will make the parsing
  // process much more robust.
  //

  io_status = reader.set_schema_file(schema_full_path_and_filename.c_str());

  if (io_status != 0)
  {
    cout << "[ERROR] set_schema_file: " << io_status << endl;
    return 1;
  }

  //
  // Tell the reader what's the file to read so it may parse the
  // metadata defining how actual data is stored.
  //


  io_status = reader.set_header_file(header_filename.c_str());

  if (io_status != 0)
  {
    cout << "[ERROR] set_header_file: " << io_status << endl;
    
    //
    // Error code 3 is a special one. It indicates that warnings, errors
    // or both have been detected when parsing the metadata. In such situation,
    // it is possible to retrieve the textual description of these problems
    // using methods get_metadata_warnings() and get_metadata_errors().
    //
    // Any other error code means that we must stop.
    //

    if (io_status != 3)
    {
      return 1;
    }
    else
    {
      //
      // Problems parsing metadata. If we've got only warnings, we may
      // continue; in the case of errors, we must stop. We'll print
      // every problem (either warnings or errors) and then decide
      // if we must exit or not.
      //

      total_warnings = reader.get_metadata_warnings(problems);

      if (total_warnings > 0)
      {
        cout << "  List of metadata warnings" << endl;
        while (!problems.empty())
        {
          cout << "  [WARNING] " << problems.front()  << endl;
          problems.pop_front();
        }
        cout << endl;
      }

      total_errors = reader.get_metadata_errors(problems);

      if (total_errors > 0)
      {
        cout << "  List of metadata errors" << endl;
        while (!problems.empty())
        {
          cout << "  [ERROR] " << problems.front()  << endl;
          problems.pop_front();
        }
        cout << endl;
      }

      // Exit only when metadata ERRORS have been detected.

      if (total_errors > 0) return 1;
    }
  }

  // --------------------------------------------------------------

  //
  // ASK THE USER.
  //
  // Depending on the type of data channel to deal with, ask the
  // appropriate questions to the user.
  //
  // If the channel is a socket, we'll ask whether to work in client
  // or server mode.
  //

  server_socket  = true;

  if (!reader.data_channel_is_socket())
  {
    // Files.

    cout << "The input data channel is a file." << endl;
  }
  else
  {
    // Sockets.

    cout << "The input data channel is a TCP socket." << endl;
    cout << "Do you wish this socket to behave as a client (0) or as a server (1) socket? ";
    cin >> read_mode;

    server_socket = (read_mode == 1);
  }

  // --------------------------------------------------------------

  //
  // SET THE READER'S CHANNEL.
  //
  // This is, in fact, necessary only when socket channels are used.
  // Nonetheless, setting the channel when files are used is
  // harmless, so, to simplify the code, the channel is set always.
  //

  reader.set_data_channel(server_socket);

  // --------------------------------------------------------------

  //
  // ASK THE USER. SET THE OUTPUT TEST FILE.
  //
  // Although this example intends to show how the event READER class
  // works, it is necessary to write the information read to somewhere
  // else, so it is possible to check that everything went right.
  //
  // Ask the user what's the name of the output ASTROLABE header file
  // as well as the base name for the external text files actually
  // storing data.
  //
  // Then, we'll use an event writer to write an output text file.
  // For a detailed explanation on how to set up and write an ASTROLABE
  // header + events file, check example test_event_writer.
  //

  cout << "Please, type the name of the output ASTROLABE header file: ";
  cin >> output_filename;

  cout << "Now type the base file name for the external text files: ";
  cin >> external_base_name;

  //
  // Build a synthetic, fake lineage. Real applications must provide with
  // proper values for the different fields in such lineage.
  //

  set_synthetic_lineage_data(output_file_lineage);

  //
  // Configure the writer using the information just obtained; other parameters
  // are just hardwired to make things easier.
  //

  io_status = writer.set_data_channel(output_filename.c_str(),
                                      external_base_name.c_str(),
                                      false,                 // Not binary, that is, text.
                                      1000000,               // Split every 1 million epochs.
                                      9,                     // Digits in the names of the split files.
                                      &output_file_lineage); // The syntetic lineage.

  // Open the output file.

  io_status = writer.open();
  if (io_status != 0)
  {
    cout << "[ERROR] open output: " << io_status << endl;
    return 1;
  }

  // --------------------------------------------------------------

  // AUXILIARY WORK.

  //
  // We will dimension the different variable length data
  // arrays according to the maximum dimension needed. To
  // do so, we'll ask the RecordStructure object about
  // the properties of all the fake records it contain.
  //
  //

  identifier_width           = 0;
  the_tags_size              = 1;
  the_expectations_size      = 1;
  the_covariance_values_size = 1;

  for (i = 0; i < record_structure_catalogue.n_l_record_types(); i++)
  {
    record_structure_catalogue.l_record_data(i, sid, n_tags, n_expectations);

    if (n_tags            > the_tags_size         ) the_tags_size = n_tags;
    if (n_expectations    > the_expectations_size ) the_expectations_size = n_expectations;
    if ((int)sid.length() > identifier_width      ) identifier_width = (int)sid.length();
  }

  the_covariance_values_size = (the_expectations_size * (the_expectations_size + 1)) / 2;

  the_tags              = new double[the_tags_size];
  the_expectations      = new double[the_expectations_size];
  the_covariance_values = new double[the_covariance_values_size];

  identifier_width++; // Take care of ending NULL characters.

  identifier = new char[identifier_width];

  // --------------------------------------------------------------

  //
  // READ THE FILE
  //
  // Open it and iterate until no more data is available. Remember that
  // simultaneously this data will be written to another ASTROLABE file.
  //

  // Try to open the reader.

  io_status = reader.open();
  if (io_status != 0)
  {
    delete the_tags;      
    delete the_expectations;
    delete the_covariance_values;

    delete identifier;

    writer.close();

    cout << "[ERROR] open: " << io_status << endl;
    return 1;
  }

  // Iterate while there are data available.

  n_epochs    = 0;
  n_l_records = 0;

  while (true)
  {
    // Read the tag type.

    io_status = reader.read_type(type);
    if (io_status != 0)
    {
      //
      // read_type is the method that, legally, may return an error
      // code stating that the file is over. Of course, other errors
      // might appear. However, when an error condition is detected,
      // the first thing to do is check if, in fact, an error condition
      // is active, since this would simply mean that the process
      // of reading the input file is over.
      //
      // Note, additionally, that the ASTROLABE parameter reader will
      // always return an "l" type, since no o-records are allowed
      // in parameter data channels.
      //

      if (reader.is_eof())
      {
        // Legal end-of-file condition.
        break;
      }
      else
      {
        //
        // The error reported by read_type is NOT an end-of-file condition.
        // Therefore, we must stop.
        //

        cout << "[ERROR] read_type: " << io_status << endl;
        break;
      }
    }

    // Read the active flag.

    io_status = reader.read_active_flag(active);
    if (io_status != 0)
    {
      cout << "[ERROR] read_active_flag: " << io_status << endl;
      break;
    }

    // Read the identifier.

    io_status = reader.read_identifier(identifier, identifier_width);
    if (io_status != 0)
    {
      cout << "[ERROR] read_identifier: " << io_status << endl;
      break;
    }

    // Read the instance identifier.

    io_status = reader.read_instance_id(instance_identifier);
    if (io_status != 0)
    {
      cout << "[ERROR] read_instance_id: " << io_status << endl;
      break;
    }

    // Read the time tag.

    io_status = reader.read_time(time_tag);
    if (io_status != 0)
    {
      cout << "[ERROR] read_time: " << io_status << endl;
      break;
    }

    //
    // At this point it is possible to ask the reader whether AN EPOCH
    // CHANGE has taken place. It is exactly after calling read_time
    // that this situation may be checked. To to so, use method
    // epoch_changed() as shown below.
    //
    // Note that the first epoch (the beginning of the data stream) is
    // never detected as an epoch change.
    //

    epoch_changed = reader.epoch_changed();

    //
    // Our only response to an epoch change in this example will be to
    // increment our counter tallying the number of these.
    //

    if (epoch_changed) n_epochs++;

    //
    // Read, the remaining data in the l-record.
    //
    // NOTE THAT THE DIMENSIONS OF ARRAYS have been set before
    // checking the dimensions of all the possible (fake) l-records
    // used in this example (by means of the "record catalogue").
    //
    // A real reader should ascertain the actual dimensions of
    // these arrays using a "mechanism" that would return these dimensions
    // using the identifier previously read in this example.
    //
    // Note, also that our fake record catalog tell us how many
    // tags or expectations (l-records) are there for each type of
    // l-record being read. This is something that must also be solved
    // somehow by a real reader (and, again, the identifier is
    // the key to solve this problem).
    //

    // Get the number of elements in the record using the fake catalogue.

    record_structure_catalogue.l_record_data(identifier, n_tags, n_expectations);

    // Read the l-record data.

    io_status = reader.read_l_data(n_tags, the_tags, n_expectations, the_expectations, n_covariance_values, the_covariance_values);
    if (io_status != 0)
    {
      cout << "[ERROR] read_l_data: " << io_status << endl;
      break;
    }

    // Write, at once, the l-record to our test output file.

    io_status = writer.write_l (active, identifier, instance_identifier, time_tag,
                                n_tags,              the_tags,
                                n_expectations,      the_expectations,
                                n_covariance_values, the_covariance_values);
    if (io_status != 0)
    {
      cout << "Error writing l record. Error code in write_l(): " << io_status << endl;
      break;
    }

    // Increment the number of l-records read.

    n_l_records++;

  }

  // Try to close the input file.

  io_status = reader.close();
  if (io_status != 0)
  {
    delete the_tags;      
    delete the_expectations;
    delete the_covariance_values;

    delete identifier;

    cout << "[ERROR] close: " << io_status << endl;

    io_status = writer.close();
    if (io_status != 0) cout << "[ERROR] close output: " << io_status << endl;

    return 1;
  }

  delete the_tags;      
  delete the_expectations;
  delete the_covariance_values;

  delete identifier;

  io_status = writer.close();
  if (io_status != 0)
  {
    cout << "[ERROR] close output: " << io_status << endl;
    return 1;
  }

  //
  // Dump some statistics to screen. Note how the number of epochs is
  // incremented by one. This is so because our reader is able to
  // detect the transition from one epoch to the next one; the first
  // epoch is never detected as a transition, so it is not in the
  // tally.
  //

  cout << "Total of l-records read: " << n_l_records << endl;
  cout << "Distributed in " << n_epochs + 1 << " epochs." << endl;

  return 0;
}
\endcode

Now , the header and implementation files for class RecordStructure are reproduced below.

Header file:

\code
#ifndef RECORDSTRUCTURE_HPP
#define RECORDSTRUCTURE_HPP

#include <string>
#include <map>

using namespace std;

/**
 * @brief Class simulating the structural information of
 *        a few obs-e based l-records.
 *
 * This class define the structural properties of a few
 * obs-e based l-records
 *
 * Such structural properties are the following:
 *
 * - the value of the identifier,
 * - the number of tag values,
 * - the dimension of the observation array (number of expectation
 *   values). This, indirectly, also sets the dimension of the
 *   covariance matrix related to the observation.
 *
 */


class RecordStructure
{
  public:

    /// @brief Default constructor.

    RecordStructure (void);

    /**
     * @brief Return the structure of an obs-e based l-record given
     * its identifier.
     *
     * @param id The identifier of the obs-e l-record whose structural
     *        information is to be sought.
     * @param n_tags Number of tags for this obs-e record.
     * @param n_expectation Number of expectations for this obs-e record.
     *
     * @return True if the identifier id corresponds to an existing
     *         obs-e record, false otherwise.
     *
     * The output values of n_tags and n_expectations only make sense
     * when this method returns true (that is, the identifier sought
     * do exist).
     *
     */

    bool l_record_data (const char* id, int& n_tags, int& n_expectations);

    /**
     * @brief Return the structure of an obs-e based l-record given
     * its internal index.
     *
     * @param index The internal index of the obs-e based l-record whose 
     *        structural information is to be sought.
     * @param id The identifier related to this obs-e based l-record.
     * @param n_tags Number of tags for this obs-e based l-record.
     * @param n_expectation Number of expectations for this obs-e based l-record.
     *
     * @return True if the identifier id corresponds to an existing
     *         obs-e based l-record, false otherwise.
     *
     * The output values of n_tags and n_expectations only make sense
     * when this method returns true (that is, the index sought
     * do exist).
     *
     * The internal index is just a number between 0 and
     * number_of_l_record_types()-1. These indexes are used to refer to the
     * observations internally.
     *
     */

    bool l_record_data (int index, string& id, int& n_tags, int& n_expectations);

    /**
     * @brief Get the number of different obs-e based l-record types simulated
     *        by this class.
     * @return The number of different l-record types simulated by
     *        this class.
     */

    int  n_l_record_types (void);

  protected:

    /// \brief Observations: number of observations modeled.

    int               l_records_available_;

    /// \brief Observations: identifiers.

    string            l_identifiers_[4];

    /// \brief Observations: number of tags.

    int               l_n_tags_[4];

    ///
    /// \brief Observations: dimension of the observation array, or
    /// number of expectation values.
    ///

    int               l_n_expectations_[4];

    ///
    /// \brief Observations: map to go from an observation identifier
    /// to the index in the arrays that defines it.
    ///

    map<string, int>  lid_to_index;
};

#endif // RECORDSTRUCTURE_HPP
\endcode

Implementation file:

\code
#include "RecordStructure.hpp"

RecordStructure::
RecordStructure
(void)
{
  {

    l_records_available_ = 4;

    l_identifiers_[0] = "LR01";
    l_identifiers_[1] = "LR02";
    l_identifiers_[2] = "LR03";
    l_identifiers_[3] = "LR04";

    l_n_tags_[0] = 1;
    l_n_tags_[1] = 0;
    l_n_tags_[2] = 2;
    l_n_tags_[3] = 0;

    l_n_expectations_[0] = 2;
    l_n_expectations_[1] = 1;
    l_n_expectations_[2] = 3;
    l_n_expectations_[3] = 2;

    lid_to_index[l_identifiers_[0]] = 0;
    lid_to_index[l_identifiers_[1]] = 1;
    lid_to_index[l_identifiers_[2]] = 2;
    lid_to_index[l_identifiers_[3]] = 3;
  }
}

bool
RecordStructure::
l_record_data
(const char* id,
 int&        n_tags,
 int&        n_expectations)
{
  {
    string looking_for(id);
    map<string,int>::iterator finder;
    int index;

    finder = lid_to_index.find(looking_for);
    if (finder == lid_to_index.end()) return false;

    index = finder->second;

    n_tags = l_n_tags_[index];
    n_expectations = l_n_expectations_[index];


    return true;
  }
}

bool
RecordStructure::
l_record_data
(int     index,
 string& id,
 int&    n_tags,
 int&    n_expectations)
{
  {
    if (index < 0) return false;
    if (index >= l_records_available_) return false;

    id = l_identifiers_[index];
    n_tags = l_n_tags_[index];
    n_expectations = l_n_expectations_[index];

    return true;
  }
}

int
RecordStructure::
n_l_record_types
(void)
{
  {
    return l_records_available_;
  }
}
\endcode
*/