/** \page wpars Writing parameter data using the generic writer classes

\section wpars-example About the example

The following is an example showing how to write through a "data channel" that will store ASTROLABE parameters.

A few comments on the example:

- This example is the counterpart of that shown in \ref rwpars. That is, the data generated by this writer is read by that tandem reader.
- This example is very similar to the one shown in \ref wobs but illustrates that parameter data channels do not include o-records.
- The main function in the example writes data to whatever channel (sockets, text or binary files).
- Function "set_synthetic_lineage_data" creates a fake lineage object with dummy data. It is necessary to write the ASTROLABE header file describing the output data.
- Note that the class RecordStructure and its methods is a mechanism devised to simulate a way to obtain easily the structural information describing a parameter, as the number of tags it includes or the dimension of the parameter vector. Therefore, an although it is necessary to run the example, it is not part of the example itself. Both the header and implementation (.hpp, .cpp) files are reproduced at the bottom of this page. Note that although very similar, these are not identical to the RecordStructure files included in the example dealing with observations (see \ref rwobs); therefore, these may NOT be exchanged.
- Furthermore, an extra auxiliary class, RecordSequence, has been included in the example. It is needed to generate a fake sequence of different l-records. Note that (1) it is not part of the example itself but it is needed to make it run and (2) in spite of having the same name, this class may not be exchanged with that present in \ref wobs - the test would crash.

\warning This example may be used to learn how to write observation RESIDUALS. The only changes to make are: (1) to use the proper header file (obs_residuals_writer.hpp" instead of "parameter_writer.hpp") and (2) to modify the class to which the object "writer" belongs (obs_residuals_reader instead of parameter_writer).

\section wpars-dependencies Dependencies

The generic parameters writer example depends on the following libraries:

- astrolabe

When using Microsoft compilers, the following library must also be added to the previous list:

- Ws2_32.lib

\section wpars-code The full example

\code
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string>

#include "RecordStructure.hpp"
#include "RecordSequence.hpp"

#include "parameter_writer.hpp"

using namespace std;

void
set_synthetic_lineage_data
(lineage_data& lineage)
{
  {
    string svalue;

    // Set the identifier.

    svalue = "ID0";
    lineage.id_set(svalue);

    // Set the name

    svalue = "Sample observation-events file";
    lineage.name_set(svalue);

    // Set the author

    svalue = "Event writer tester program";
    lineage.author_item_add(svalue);

    // Set the organization

    svalue = "The name of the organization goes here";
    lineage.organization_set(svalue);

    // Set the department.

    svalue = "The name of the department goes here";
    lineage.department_set(svalue);

    // Set the project

    svalue = "The name of the project goes here";
    lineage.project_set(svalue);

    // Set the task

    svalue = "The name of the task goes here";
    lineage.task_set(svalue);

    // Set the reference documents

    svalue = "As many entries as desired may be added to refer to related documentation";
    lineage.ref_document_item_add(svalue);

    // Set the remarks

    svalue = "Any interesting remarks go here";
    lineage.remarks_set(svalue);

  }
}

int
main
(int argv, char** argc)
{
  {
    //
    // Data obtained from the user, which will be used to
    // select and configure our data channel.
    //

    int     device_format;
    string  external_base_name;
    string  host;
    string  outfile_name;
    int     port;
    int     server_mode;

    //
    // Data arrays for l-records. Related
    // dimensions.
    //

    double* the_tags;
    double* the_expectations;
    double* the_covariance_values;

    int     the_tags_size;
    int     the_expectations_size;
    int     the_covariance_values_size;

    int     n_tags;
    int     n_expectations;
    int     n_covariance_values;

    // Metadata to generate fake l- and o- records.

    string  sid;
    char*   identifier;
    int     identifier_width;
    double  time_tag;
    int     record_id_index;
    int     cycle;

    // The ASTROLABE generic parameter writer.

    parameter_writer writer;

    // Synthetic (nonsensical) lineage to add to the ASTROLABE header file.

    lineage_data file_lineage;

    //
    // The auxiliary classes that will generate record
    // sequence hints and will describe the structure
    // or these records.
    //

    RecordSequence  the_record_sequence;
    RecordStructure record_structure_catalogue;

    // Other auxiliary variables, as error codes or loop indices.

    int     i;
    int     line_index;
    int     random_value;
    int     io_status;
    int     total_lines;

    // --------------------------------------------------------------

    // PRELIMINARY WORK.

    //
    // We will dimension the different variable length data
    // arrays according to the maximum dimension needed. To
    // do so, we'll ask the RecordStructure object about
    // the properties of all the fake records it contain.
    //

    identifier_width           = 0;
    the_tags_size              = 1;
    the_expectations_size      = 1;
    the_covariance_values_size = 1;

    for (i = 0; i < record_structure_catalogue.n_l_record_types(); i++)
    {
      record_structure_catalogue.l_record_data(i, sid, n_tags, n_expectations);

      if (n_tags            > the_tags_size         ) the_tags_size = n_tags;
      if (n_expectations    > the_expectations_size ) the_expectations_size = n_expectations;
      if ((int)sid.length() > identifier_width      ) identifier_width = (int)sid.length();
    }

    the_covariance_values_size = (the_expectations_size * (the_expectations_size + 1)) / 2;

    the_tags              = new double[the_tags_size];
    the_expectations      = new double[the_expectations_size];
    the_covariance_values = new double[the_covariance_values_size];

    identifier = new char[identifier_width + 1];

    identifier[identifier_width] = 0;
    time_tag                     = 1.0;

    // --------------------------------------------------------------

    //
    // ASK THE USER.
    //
    // Get the format of the device (text or binary file, socket)
    // to deal with.
    //

    external_base_name = "";
    device_format = 0;

    while ((device_format <= 0) || (device_format > 4))
    {

      cout << "Type of output file to create" << endl << endl;
      cout << "  Binary file : 1" << endl;
      cout << "  Text file   : 2" << endl;
      cout << "  Socket      : 3" << endl;
      cout << "  QUIT!!!     : 4" << endl << endl;
      cout << " Your choice? : ";
      cin >> device_format;
    }

    if (device_format == 4) return 0;

    // Set the writer channel according to its type.

    if (device_format <= 2)
    {
      // File. Get its name.

      cout << "Name of the ASTROLABE header file: ";
      cin >> outfile_name;

      if (device_format <= 2)
      {
        cout << "Base name for the external splitted files: ";
        cin >> external_base_name;
      }

      //
      // No matter the type of file we're dealing with, we must provide with a lineage,
      // which is part of the header included in the ASTROLABE header file.
      // We generate here a "synthetic" noe (including nonsensical values).
      //

      set_synthetic_lineage_data(file_lineage);

    }
    else
    {
      // Sockets.

      cout << "Port to use                      : ";
      cin  >> port;

      server_mode = -1;
      while ((server_mode < 0) | (server_mode > 1))
      {
        cout << "Work as server (0) or client (1) : ";
        cin >> server_mode;
      }

      host = "";
      if (server_mode == 1)
      {
        cout << "Host or IP address to connect to : ";
        cin  >> host;
      }
    }

    // --------------------------------------------------------------

    //
    // SET THE DEVICE CHANNEL according to the data provided by the
    // user.
    //

    switch (device_format)
    {
      case 1:

        // Binary files.

        //
        // We fix the maximum number of epoch per chunk to 100 and the suffix
        // witdh to 9. These values could be any within the legal ranges.
        //

        io_status = writer.set_data_channel(outfile_name.c_str(),
                                            external_base_name.c_str(),
                                            true,  // Binary
                                            100,
                                            9,
                                            &file_lineage);
        break;

      case 2:

        // Text files.

        //
        // We fix the maximum number of epoch per chunk to 100 and the suffix
        // witdh to 9. These values could be any within the legal ranges.
        //

        io_status = writer.set_data_channel(outfile_name.c_str(),
                                            external_base_name.c_str(),
                                            false, // Not binary, that is, text.
                                            100,
                                            9,
                                            &file_lineage);

        break;

      case 3:

        // Sockets.

        io_status = writer.set_data_channel(host.c_str(), port, (server_mode == 0));

        break;
    }

    // Check that the data channel has been correctly set.

    if (io_status != 0)
    {
      cout << "set_data_channel reported error code " << io_status << endl;
      return 0;
    }


    // --------------------------------------------------------------

    //
    // WRITE DATA to the selected channel, whatever it is.
    //

    // Open the underlying channel.

    io_status = writer.open();
    if (io_status != 0)
    {
      cout << "open() reported error code: " << io_status << endl;
      return 1;
    }


    //
    // Insert 1000 full cycles of the sequence of records provided by
    // our RecordSequence object. Each cycle corresponds to a full epoch.
    // All records will be l-records (this is a parameter writer, there
    // are no o-records).
    //

    total_lines = 1000 * the_record_sequence.cycle_length();

    for (line_index = 0; line_index < total_lines; line_index++)
    {

      //
      // Get the next record index.
      //

      the_record_sequence.get_next(record_id_index, cycle);

      time_tag = (double)cycle;

      //
      // Retrieve the structural information for the l-record
      // whose index we've just generated. Then, generate fake
      // data for the l-record and write it to the output file.
      //

      record_structure_catalogue.l_record_data(record_id_index, sid, n_tags, n_expectations);

      // Identifier.

      identifier = strcpy(identifier, sid.c_str());

      //
      // Decide randomly the shape of the covariance matrix: none, only
      // standard deviations, full matrix (including correlations).
      // Generate fake values at the same time.
      //

      random_value = rand() % 100 + 1;

      if (random_value <= 5)
      {
        n_covariance_values = 0;
      } else if (random_value <= 95)
      {
        n_covariance_values = n_expectations;
        for (i = 0; i < n_covariance_values; i++)
        {
          the_covariance_values[i] = (double)(i + line_index);
        }
      } else
      {
        n_covariance_values = (n_expectations * (n_expectations + 1)) / 2;
        for (i = 0; i < n_covariance_values; i++)
        {
          the_covariance_values[i] = (double)(i + line_index);
        }
        for (i = n_expectations; i < n_covariance_values; i++)
        {
          the_covariance_values[i] = (double)i / 100;
        }
      }

      // Generate fake data for the tags and expectations.

      for (i = 0; i < n_tags;         i++) the_tags[i]         = (double)(i + line_index);
      for (i = 0; i < n_expectations; i++) the_expectations[i] = (double)(i + line_index + 1);

      // Write the l-record.

      io_status = writer.write_l (true, identifier, line_index, time_tag,
                                  n_tags,              the_tags,
                                  n_expectations,      the_expectations,
                                  n_covariance_values, the_covariance_values);
      if (io_status != 0)
      {
        cout << "Error writing l record. Error code in write_l(): " << io_status << endl;
        break;
      }
    }


    // Close the writer.

    io_status =  writer.close();
    if (io_status != 0) cout << "Error closing file. Error code in close(): " << io_status;

    // Cleaning.

    delete identifier;
    delete the_tags;        
    delete the_expectations;
    delete the_covariance_values;

  }

  return 0;
}
\endcode

Now , the header and implementation files for class RecordStructure are reproduced below.

Header file:

\code
#ifndef RECORDSTRUCTURE_HPP
#define RECORDSTRUCTURE_HPP

#include <string>
#include <map>

using namespace std;

/**
 * @brief Class simulating the structural information of
 *        a few obs-e based l-records.
 *
 * This class define the structural properties of a few
 * obs-e based l-records
 *
 * Such structural properties are the following:
 *
 * - the value of the identifier,
 * - the number of tag values,
 * - the dimension of the observation array (number of expectation
 *   values). This, indirectly, also sets the dimension of the
 *   covariance matrix related to the observation.
 *
 */


class RecordStructure
{
  public:

    /// @brief Default constructor.

    RecordStructure (void);

    /**
     * @brief Return the structure of an obs-e based l-record given
     * its identifier.
     *
     * @param id The identifier of the obs-e l-record whose structural
     *        information is to be sought.
     * @param n_tags Number of tags for this obs-e record.
     * @param n_expectation Number of expectations for this obs-e record.
     *
     * @return True if the identifier id corresponds to an existing
     *         obs-e record, false otherwise.
     *
     * The output values of n_tags and n_expectations only make sense
     * when this method returns true (that is, the identifier sought
     * do exist).
     *
     */

    bool l_record_data (const char* id, int& n_tags, int& n_expectations);

    /**
     * @brief Return the structure of an obs-e based l-record given
     * its internal index.
     *
     * @param index The internal index of the obs-e based l-record whose 
     *        structural information is to be sought.
     * @param id The identifier related to this obs-e based l-record.
     * @param n_tags Number of tags for this obs-e based l-record.
     * @param n_expectation Number of expectations for this obs-e based l-record.
     *
     * @return True if the identifier id corresponds to an existing
     *         obs-e based l-record, false otherwise.
     *
     * The output values of n_tags and n_expectations only make sense
     * when this method returns true (that is, the index sought
     * do exist).
     *
     * The internal index is just a number between 0 and
     * number_of_l_record_types()-1. These indexes are used to refer to the
     * observations internally.
     *
     */

    bool l_record_data (int index, string& id, int& n_tags, int& n_expectations);

    /**
     * @brief Get the number of different obs-e based l-record types simulated
     *        by this class.
     * @return The number of different l-record types simulated by
     *        this class.
     */

    int  n_l_record_types (void);

  protected:

    /// \brief Observations: number of observations modeled.

    int               l_records_available_;

    /// \brief Observations: identifiers.

    string            l_identifiers_[4];

    /// \brief Observations: number of tags.

    int               l_n_tags_[4];

    ///
    /// \brief Observations: dimension of the observation array, or
    /// number of expectation values.
    ///

    int               l_n_expectations_[4];

    ///
    /// \brief Observations: map to go from an observation identifier
    /// to the index in the arrays that defines it.
    ///

    map<string, int>  lid_to_index;
};

#endif // RECORDSTRUCTURE_HPP
\endcode

Implementation file:

\code
#include "RecordStructure.hpp"

RecordStructure::
RecordStructure
(void)
{
  {

    l_records_available_ = 4;

    l_identifiers_[0] = "LR01";
    l_identifiers_[1] = "LR02";
    l_identifiers_[2] = "LR03";
    l_identifiers_[3] = "LR04";

    l_n_tags_[0] = 1;
    l_n_tags_[1] = 0;
    l_n_tags_[2] = 2;
    l_n_tags_[3] = 0;

    l_n_expectations_[0] = 2;
    l_n_expectations_[1] = 1;
    l_n_expectations_[2] = 3;
    l_n_expectations_[3] = 2;

    lid_to_index[l_identifiers_[0]] = 0;
    lid_to_index[l_identifiers_[1]] = 1;
    lid_to_index[l_identifiers_[2]] = 2;
    lid_to_index[l_identifiers_[3]] = 3;
  }
}

bool
RecordStructure::
l_record_data
(const char* id,
 int&        n_tags,
 int&        n_expectations)
{
  {
    string looking_for(id);
    map<string,int>::iterator finder;
    int index;

    finder = lid_to_index.find(looking_for);
    if (finder == lid_to_index.end()) return false;

    index = finder->second;

    n_tags = l_n_tags_[index];
    n_expectations = l_n_expectations_[index];


    return true;
  }
}

bool
RecordStructure::
l_record_data
(int     index,
 string& id,
 int&    n_tags,
 int&    n_expectations)
{
  {
    if (index < 0) return false;
    if (index >= l_records_available_) return false;

    id = l_identifiers_[index];
    n_tags = l_n_tags_[index];
    n_expectations = l_n_expectations_[index];

    return true;
  }
}

int
RecordStructure::
n_l_record_types
(void)
{
  {
    return l_records_available_;
  }
}
\endcode

Finally , the header and implementation files for class RecordSequence are included below.

Header file:
\code
#ifndef RECORDSEQUENCE_HPP
#define RECORDSEQUENCE_HPP


class RecordSequence
{
  public:

    /// @brief Return the length of the sequence cycle

    int cycle_length (void);

    /**
     * @brief Get the next item in the sequence.
     * @param record_id_index The index of the identifier of the
     *        record to generate.
     * @param cycle Cycle number. Each time that the sequence is
     *        exhausted, this cycle number is increased by one. May
     *        be used to simulate time tags.
     */

    void get_next(int& record_id_index, int& cycle);

    /// \brief Default constructor.

    RecordSequence  (void);

    /// \brief Destructor

    ~RecordSequence (void);

  protected:

    /// Current index of the record sequence.

    int record_sequence_index_;

    /// Current record sequence cycle.

    int record_sequence_cycle_;

    /// Period of the record sequence.

    int record_sequence_length_;

    ///
    /// Record sequence. Identifier indexes of the successive
    /// records in the sequence.
    ///

    int* record_sequence_ids_;

};

#endif // RECORDSEQUENCE_HPP
\endcode

Implementation file:

\code
#include "RecordSequence.hpp"

int
RecordSequence::
cycle_length
(void)
{
  {
    return record_sequence_length_;
  }
}

void
RecordSequence::
get_next
(int& record_id_index, int& cycle)
{
  {
    record_id_index = record_sequence_ids_[record_sequence_index_];
    cycle           = record_sequence_cycle_;

    record_sequence_index_++;

    if (record_sequence_index_ == record_sequence_length_)
    {
      record_sequence_index_ = 0;
      record_sequence_cycle_++;
    }
  }
}

RecordSequence::
RecordSequence
(void)
{
  {
    record_sequence_length_ = 10;
    record_sequence_ids_  = new int[record_sequence_length_];

    record_sequence_ids_[0]  = 3;
    record_sequence_ids_[1]  = 2;
    record_sequence_ids_[2]  = 1;
    record_sequence_ids_[3]  = 1;
    record_sequence_ids_[4]  = 0;
    record_sequence_ids_[5]  = 3;
    record_sequence_ids_[6]  = 2;
    record_sequence_ids_[7]  = 1;
    record_sequence_ids_[8]  = 0;
    record_sequence_ids_[9]  = 1;

    record_sequence_index_ = 0;
    record_sequence_cycle_ = 0;
  }
}

RecordSequence::
~RecordSequence
(void)
{
  {
    delete record_sequence_ids_;
  }
}
\endcode
*/